# Generator Pipeline Architecture and Patterns

Detailed guide to the two-stage generator pipeline. Reference this when implementing new analysis rules, metadata extraction, or code generation features.

## Pipeline Overview

The generator processes user code through two sequential transformation stages:

```
User Code (Compilation)
  ↓ [Stage 1: Metadata Extraction]
  ├─ Parse specifications, injectors, factories, builders, attributes
  ├─ Extract metadata from syntax and semantic models
  ├─ Create metadata models mirroring code structure
  └─ Validate and collect diagnostics
  ↓ [Stage 2: Code Generation and Rendering]
  ├─ Map metadata to output templates
  ├─ Generate C# code
  ├─ Apply formatting
  └─ Write .generated.cs files
```

## Stage 1: Metadata Extraction

**Responsibility**: Extract metadata from user code by parsing specifications, injectors, and their members. Build metadata models that mirror the source code structure.

**Input**: User code AST and semantic models (via Roslyn)

**Output**: Metadata models describing specifications, injectors, factories, builders, and attributes

### Metadata Model Characteristics

- **Syntax-derived**: Mirrors actual code structure
- **Type-safe**: References ISymbol/ITypeSymbol from Roslyn
- **Declarative**: Records what exists in code, not what it means
- **Equatable**: Uses EquatableList for structural equality (required for incremental caching)

Example metadata:

```csharp
public record SpecificationMetadata(
    string Name,
    INamedTypeSymbol Symbol,
    EquatableList<SpecFactoryMethodMetadata> FactoryMethods,
    EquatableList<AttributeMetadata> Attributes
);

public record SpecFactoryMethodMetadata(
    string Name,
    IMethodSymbol Symbol,
    ITypeSymbol ReturnType,
    EquatableList<ParameterMetadata> Parameters
);

public record ParameterMetadata(
    string Name,
    ITypeSymbol Type,
    int Position
);
```

### Implementation Pattern

Use syntax-level predicates for performance, then extract metadata:

```csharp
var metadataProvider = context.SyntaxProvider.CreateSyntaxProvider(
    predicate: (syntax, _) => {
        // Fast: check syntax node type only
        return syntax is ClassDeclarationSyntax { AttributeLists: not [] };
    },
    transform: (ctx, _) => {
        // Expensive: only on filtered candidates
        return ExtractSpecificationMetadata(ctx);
    }
);
```

### Key Points

- **No complex validation**: Metadata extraction focuses on syntax/semantic parsing
- **Performance critical**: Use fast predicates to filter candidates
- **Use EquatableList**: All collections must use EquatableList for incremental caching
- **Diagnostic errors**: Report syntactic issues (missing attributes, invalid symbols)

## Stage 2: Code Generation and Rendering

**Responsibility**: Transform metadata into generated C# code. Map metadata models to output templates and render as source files.

**Input**: Metadata models from Stage 1

**Output**: Generated .cs files

### Code Generation Process

The stage maps metadata to code templates and renders them:

```csharp
// Map metadata to template
var injectorTemplate = MapInjectorMetadata(metadata);

// Render template to C# code
var code = RenderInjectorCode(injectorTemplate);

// Write to file
context.AddSource($"{injectorTemplate.Name}.g.cs", code);
```

### Generated Code Standards

All generated code must follow [Code Generation Practices](../../.agents/code-generation.md):

- Include `// <auto-generated />` header
- Include nullability directives `#nullable enable/restore`
- Apply consistent indentation (4 spaces)
- Use readable formatting
- No runtime validation (all validation done at generation time)

### Key Points

- **Direct transformation**: Metadata → Code
- **No intermediate models**: Code generation happens directly from metadata
- **Formatting**: Apply consistent formatting to generated code
- **Diagnostics**: Report generation issues as they occur

## Validation Checklist

When implementing pipeline stages:

- **Stage 1**: Metadata uses syntax-level predicates; EquatableList for all collections
- **Stage 2**: Generated code follows standards; diagnostics are clear
- **Cross-stage**: Each stage is independent; outputs consumable by next stage
- **Performance**: Large specifications generate quickly (< 500ms)
- **Diagnostics**: All errors reported to users with actionable messages

## References

- **[Architecture Guide](../../.agents/architecture.md)**: System overview and design goals
- **[Code Generation Practices](../../.agents/code-generation.md)**: Generated code standards
- **[Coding Standards](../../.agents/coding-standards.md)**: C# guidelines
