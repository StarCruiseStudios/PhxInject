# Architecture Guide for PhxInject

This guide explains the overall system design, component relationships, and architectural patterns in PhxInject. Read this first to understand the context for all other agent instructions.

## System Overview

PhxInject is a compile-time dependency injection framework for .NET consisting of:

- **Phx.Inject** (core library): Attributes, public API, contracts
- **Phx.Inject.Generator** (source generator): Roslyn generator that analyzes specifications and generates injection code

### Design Goals

1. **Zero-Runtime Overhead**: All work happens at compile time
2. **Clear Compile-Time Errors**: Invalid dependencies caught before runtime
3. **No Reflection**: Generated code uses direct calls, no reflection overhead
4. **Fast Generation**: Large projects must generate code quickly
5. **Composable**: Multiple specifications and injectors work together seamlessly

## System Structure

### The Three Components

PhxInject consists of three interconnected parts:

1. **Phx.Inject Library** - A library that user code consumes. It provides:
   - Attributes users apply to their code: `[Specification]`, `[Factory]`, `[Builder]`, `[Injector]`
   - Exception types for DI errors
   - Public interfaces or types other libraries depend on

2. **User Code** - Code written by developers who use PhxInject. They define:
   - Classes with `[Specification]` attribute containing factory and builder methods
   - Interfaces with `[Injector]` attribute defining the public DI API
   - Use these to declare their system's dependencies
   - See [Documentation/index.md](../../../Documentation/index.md) for user-oriented examples and guidance.

3. **Phx.Inject.Generator** - A Roslyn incremental source generator (this repository's focus). At compile time, it:
   - Inspects the user's code for attributes and types defined in Phx.Inject
   - Analyzes specifications and injectors to understand the dependency graph
   - Generates efficient, direct-call injection code
   - Reports compile-time errors for invalid configurations
   - **Note**: The agent instructions in this repository are for modifying the generator, not for using the library.

### The Generator Pipeline

Phx.Inject.Generator processes user code through five stages:

**Stage 1: Metadata** - Create a model of injection-related types found in user code (specifications, injectors, factories, builders). This metadata model mirrors the constructs defined in the user code to facilitate processing without having to work with raw reflection types.

**Stage 2: Core** - Transform the metadata model into core domain models representing the business concepts of dependency injection (e.g., `Specification`, `Injector`, `Factory`, `Builder`, `Dependency`). These domain models capture the semantic meaning defined in the metadata model without implementation logic.

**Stage 3: Linking** - Build the dependency graph by linking core models together. This stage:
- Matches injector methods to specification factories/builders
- Resolves parameter dependencies recursively  
- Detects cycles and conflicts
- Produces complete dependency graphs

**Stage 4: Code Generation** - Process the linked dependency graph and generate a template model describing the structure of code to be generated. This mirrors the semantic model the generated code will look like without yet rendering it or assuming rendered code implementation structure.

**Stage 5: Rendering** - Transform the template model into actual C# code and write `.generated.cs` files.

## Key Design Patterns

### 1. Specification Pattern

A specification is a container for all dependency definitions:

- **Static classes**: No instance state, factories are static methods
- **Instance classes**: Specification instances are constructed by user code and passed in to injectors.
- **Dependency injection**: Specifications generated by a Parent injector and provide to a child injector to share dependencies.

This allows:
- Grouping related dependencies
- Reusing specifications across multiple injectors
- Replacing specifications for testing

### 2. Factory/Builder Pattern

**Factories** create new instances:
- Methods returning a type
- May accept parameters (dependency injection)
- Each call creates a new instance

**Builders** modify existing instances:
- Methods accepting a target instance parameter
- May accept other parameters (dependency injection)
- Useful for complex initialization when the dependency injection framework does not have access to the constructor

### 3. Incremental Generation

The generator uses incremental incremental source generation:

- Only re-generate when source changes
- Cache analysis results across invocations
- Fast re-generation on edit cycles

### 4. Diagnostic-Driven Design

Errors are reported as diagnostics:

- Invalid specifications generate warnings/errors
- Unresolved dependencies caught at compile time
- User gets actionable error messages with locations

## Component Relationships

The generator processes user code through five sequential stages:

```
User Code (Specification + Injector attributes)
    ↓ [Stage 1: Metadata]
    ├─ Extract syntactic metadata
    ↓ [Stage 2: Core]
    ├─ Transform to domain models
    ↓ [Stage 3: Linking]
    ├─ Build dependency graph
    ↓ [Stage 4: Code Generation]
    ├─ Generate template model
    ↓ [Stage 5: Rendering]
    └─ Output C# code
```

(See [Generator Pipeline Architecture](../src/Phx.Inject.Generator/.agents/generator-pipeline.md) for detailed description of each stage.)

## Key Invariants

Maintain these invariants when adding features:

1. **No Reflection at Runtime**: Generated code uses only direct calls
2. **Specification Closure**: All dependencies must be resolvable from the injector's specifications
3. **Acyclic Dependencies**: Circular dependencies must be detected at compile time
4. **Type Safety**: Matching must be type-safe; no duck typing
5. **Deterministic Generation**: Same input always produces same output

## Common Modification Points

When adding features, modifications typically fall into these categories:

1. **New Attribute Types**: Add to Phx.Inject, document their semantics
2. **New Analysis Rules**: Modify specification analyzer in generator
3. **New Generation Logic**: Extend code generator templates
4. **New Linking Rules**: Update the dependency linker/matcher
5. **New Diagnostics**: Add to diagnostic reporter

Each typically requires changes in both Phx.Inject and Generator projects.

## Testing Strategy

**To be detailed in [Testing Standards](testing.md). For now, understand that:**

- Tests validate the generator pipeline at multiple levels
- Both the code generation logic and generated code are tested
- Tests ensure correctness across variations of user specifications

### Legacy Versions

The repository currently contains legacy implementations:

- `Phx.Inject.Generator.Legacy` and `Phx.Inject.Legacy`: Reference implementations using older Roslyn APIs
- Parallel test projects: `Phx.Inject.Tests.Legacy` and `Phx.Inject.Generator.Tests.Legacy`

**Status**: These versions are included for reference while the generator is updated to use incremental source generators. They will eventually be deleted. Agents can refer to them to understand expected behavior, but they can otherwise be ignored. Focus work on the current (non-Legacy) versions.

## Performance Considerations

Source generation must be fast:

- Avoid unnecessary allocations in hot paths (analyzers, linkers)
- Incremental generation caches results aggressively
- Generated code is efficient by design (direct calls)
- Large projects (100+ dependencies) must generate quickly
