# Architecture Guide for PhxInject

This guide explains the overall system design, component relationships, and architectural patterns in PhxInject. Read this first to understand the context for all other agent instructions.

## System Overview

PhxInject is a compile-time dependency injection framework for .NET consisting of:

- **Phx.Inject** (core library): Attributes, public API, contracts
- **Phx.Inject.Generator** (source generator): Roslyn generator that analyzes specifications and generates injection code

### Design Goals

1. **Zero-Runtime Overhead**: All work happens at compile time
2. **Clear Compile-Time Errors**: Invalid dependencies caught before runtime
3. **No Reflection**: Generated code uses direct calls, no reflection overhead
4. **Fast Generation**: Large projects must generate code quickly
5. **Composable**: Multiple specifications and injectors work together seamlessly

## System Structure

### The Three Components

PhxInject consists of three interconnected parts:

1. **Phx.Inject Library** - A library that user code consumes. It provides:
   - Attributes users apply to their code: `[Specification]`, `[Factory]`, `[Builder]`, `[Injector]`
   - Exception types for DI errors
   - Public interfaces or types other libraries depend on

2. **User Code** - Code written by developers who use PhxInject. They define:
   - Classes with `[Specification]` attribute containing factory and builder methods
   - Interfaces with `[Injector]` attribute defining the public DI API
   - Use these to declare their system's dependencies
   - See [Documentation/index.md](../../../Documentation/index.md) for user-oriented examples and guidance.

3. **Phx.Inject.Generator** - A Roslyn incremental source generator (this repository's focus). At compile time, it:
   - Inspects the user's code for attributes and types defined in Phx.Inject
   - Analyzes specifications and injectors to understand the dependency graph
   - Generates efficient, direct-call injection code
   - Reports compile-time errors for invalid configurations
   - **Note**: The agent instructions in this repository are for modifying the generator, not for using the library.

### The Generator Pipeline

Phx.Inject.Generator processes user code through a two-stage pipeline:

**Stage 1: Metadata Extraction** - Extract syntactic metadata from user code (specifications, injectors, factories, builders, attributes). This metadata model mirrors the constructs defined in the user code using Roslyn syntax and semantic models.

**Stage 2: Code Generation and Rendering** - Transform metadata into generated C# code. This stage maps metadata models to output templates and renders them as `.generated.cs` files.

## Key Design Patterns

### 1. Specification Pattern

A specification is a container for all dependency definitions:

- **Static classes**: No instance state, factories are static methods
- **Instance classes**: Specification instances are constructed by user code and passed in to injectors.
- **Dependency injection**: Specifications generated by a Parent injector and provide to a child injector to share dependencies.

This allows:
- Grouping related dependencies
- Reusing specifications across multiple injectors
- Replacing specifications for testing

### 2. Factory/Builder Pattern

**Factories** create new instances:
- Methods returning a type
- May accept parameters (dependency injection)
- Each call creates a new instance

**Builders** modify existing instances:
- Methods accepting a target instance parameter
- May accept other parameters (dependency injection)
- Useful for complex initialization when the dependency injection framework does not have access to the constructor

### 3. Incremental Generation

The generator uses incremental incremental source generation:

- Only re-generate when source changes
- Cache analysis results across invocations
- Fast re-generation on edit cycles

### 4. Diagnostic-Driven Design

Errors are reported as diagnostics:

- Invalid specifications generate warnings/errors
- Unresolved dependencies caught at compile time
- User gets actionable error messages with locations

## Component Relationships

The generator processes user code through two sequential stages:

```
User Code (Specification + Injector attributes)
    ↓ [Stage 1: Metadata Extraction]
    ├─ Parse syntax and extract semantic metadata
    ├─ Create metadata models for specifications, injectors, factories, builders
    ↓ [Stage 2: Code Generation and Rendering]
    ├─ Map metadata to output templates
    ├─ Generate C# code
    └─ Output .generated.cs files
```

(See [Generator Pipeline Architecture](../src/Phx.Inject.Generator/.agents/generator-pipeline.md) for detailed description of each stage.)

## Key Invariants

Maintain these invariants when adding features:

1. **No Reflection at Runtime**: Generated code uses only direct calls
2. **Specification Closure**: All dependencies must be resolvable from the injector's specifications
3. **Acyclic Dependencies**: Circular dependencies must be detected at compile time
4. **Type Safety**: Matching must be type-safe; no duck typing
5. **Deterministic Generation**: Same input always produces same output

## Common Modification Points

When adding features, modifications typically fall into these categories:

1. **New Attribute Types**: Add to Phx.Inject, document their semantics
2. **New Analysis Rules**: Modify specification analyzer in generator
3. **New Generation Logic**: Extend code generator templates
4. **New Linking Rules**: Update the dependency linker/matcher
5. **New Diagnostics**: Add to diagnostic reporter

Each typically requires changes in both Phx.Inject and Generator projects.

## Testing Strategy

Testing strategy is not yet defined. See [Testing Standards](testing.md) for current status.

### Legacy Versions

The repository currently contains legacy implementations:

- `Phx.Inject.Generator.Legacy` and `Phx.Inject.Legacy`: Reference implementations using older Roslyn APIs
- Parallel test projects: `Phx.Inject.Tests.Legacy` and `Phx.Inject.Generator.Tests.Legacy`

**Status**: These versions are included for reference while the generator is updated to use incremental source generators. They will eventually be deleted. Agents can refer to them to understand expected behavior, but they can otherwise be ignored. Focus work on the current (non-Legacy) versions.

## Performance Considerations

Source generation must be fast:

- Avoid unnecessary allocations in hot paths (analyzers, linkers)
- Incremental generation caches results aggressively
- Generated code is efficient by design (direct calls)
- Large projects (100+ dependencies) must generate quickly
