# Code Generation Practices for PhxInject

Standards for writing source generators and for the code those generators produce. This applies to Phx.Inject.Generator.

## Source Generator Architecture

PhxInject uses incremental source generators for performance:

```csharp
[Generator]
public class PhxInjectSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1. Define input providers (what to analyze)
        // 2. Transform providers (analysis stages)
        // 3. Register output (generated code)
    }
}
```

### Incremental Generator Pattern

Structure generators following this pattern:

```csharp
[Generator]
public class MyAnalyzer : IIncrementalGenerator {
    public void Initialize(IncrementalGeneratorInitializationContext context) {
        // Define what to analyze
        var syntaxProvider = context.SyntaxProvider.CreateSyntax
            Predicate(...) // Filter: quick syntactic check
            .Select((syntax, _) => Transform(syntax)); // Transform to semantic model
        
        // Transform: analysis stage
        var analyzed = syntaxProvider
            .Combine(context.CompilationProvider)
            .Select((pair, _) => Analyze(pair.Left, pair.Right));
        
        // Generate
        context.RegisterSourceOutput(analyzed, (ctx, item) => {
            ctx.AddSource($"{item.Name}.g.cs", item.GeneratedCode);
        });
    }
}
```

### Performance Considerations

**DO**:
- Use incremental providers for caching
- Return early from predicates to skip Roslyn parsing
- Cache expensive semantic analysis
- Use `HashCode` for determinate output

**DON'T**:
- Enumerate compilation symbols unnecessarily
- Re-analyze unchanged symbols
- Create many intermediate collections
- Call `FullyQualifiedName` repeatedly (cache results)

Example optimization:

```csharp
// Good: cache fully qualified names
private static string GetCachedName(INamedTypeSymbol symbol) {
    var key = SymbolEqualityComparer.Default.GetHashCode(symbol);
    if (_nameCache.TryGetValue(key, out var name)) {
        return name;
    }
    
    name = symbol.GetFullyQualifiedName();
    _nameCache[key] = name;
    return name;
}

// Avoid: repeated computation
var name1 = symbol.GetFullyQualifiedName();
var name2 = symbol.GetFullyQualifiedName(); // Recomputed
```

## Generated Code Standards

Code generated by the source generator must follow these standards:

### 1. Code Style

Generated code must be readable by human eyes:

```csharp
// Good: formatted and indented
public class GeneratedTestInjector : ITestInjector
{
    public int GetInt()
    {
        return TestSpecification.GetIntValue();
    }
    
    public MyClass GetMyClass()
    {
        var intValue = TestSpecification.GetIntValue();
        return TestSpecification.GetMyClass(intValue);
    }
}

// Avoid: compressed/unreadable
public class GeneratedTestInjector:ITestInjector{public int GetInt(){return TestSpecification.GetIntValue();}}
```

### 2. Source Information

Always include source information for debugging:

```csharp
[System.CodeDom.Compiler.GeneratedCode("Phx.Inject.Generator", "1.0")]
[System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
public class GeneratedTestInjector : ITestInjector
{
    // Generated implementation
}
```

Also include file comment:

```csharp
// <auto-generated />
// This file is generated by Phx.Inject.Generator.
// Do not modify directly - changes will be overwritten.
#pragma warning disable CS1591 // Missing XML documentation

namespace My.Project.Generated
{
    // ...
}
```

### 3. Nullability

Generated code must declare nullability explicitly:

```csharp
#nullable enable

public class GeneratedInjector : IMyInjector
{
    // Declare that methods never return null
    public string GetName() => GetNameFromSpec();
    
    // Or may be null
    public string? GetOptionalName() => _spec.GetOptionalName();
}

#nullable restore
```

### 4. Method Generation

### Simple Factories

```csharp
// For static factory with no parameters
public MyType GetMyType() => MySpec.CreateMyType();

// For factory with dependencies
public MyType GetMyType()
{
    var dependency = GetDependency();
    return MySpec.CreateMyType(dependency);
}
```

### Builders

```csharp
public void Build(MyType target)
{
    var dependency = GetDependency();
    MySpec.BuildMyType(target, dependency);
}
```

### Chaining Dependencies

```csharp
// If A depends on B depends on C:
public A GetA()
{
    var c = GetC();  // Leaf dependency
    var b = GetB(c); // Intermediate
    return GetA(b);  // Root
}

// But cache if used multiple times:
public A GetA()
{
    var c = GetC();
    var b1 = GetB(c);
    var b2 = GetB(c); // Reuse c, but don't duplicate GetB
    return GetA(b1, b2);
}
```

### 5. Error Prevention

Generated code must validate at generation time, not runtime:

**Good**: Validation errors as diagnostics
```csharp
// In generator, not in generated code:
if (!CanResolveDependency(method)) {
    context.ReportDiagnostic(Diagnostic.Create(
        UnresolvableDependencyDescriptor,
        method.Locations[0],
        method.Name));
    return; // Don't generate broken code
}
```

**Avoid**: Runtime validation in generated code
```csharp
// Don't generate this:
public MyType GetMyType()
{
    if (depedency == null) {
        throw new InvalidOperationException("Dependency not configured");
    }
    return dependency.Create();
}
```

### 6. Comments in Generated Code

Only include comments when behavior is non-obvious:

```csharp
// Good: explains why this chain is necessary
public MyType GetMyType()
{
    // Dependency A requires B, which requires C; resolve in order
    var c = GetC();
    var b = GetB(c);
    return GetA(b);
}

// Avoid: obvious comments
public MyType GetMyType()
{
    // Get C
    var c = GetC();
    // Get B passing C
    var b = GetB(c);
    // Return A passing B
    return GetA(b);
}
```

## Template Generation

For generating method bodies, use StringBuilder with proper indentation:

```csharp
private static string GenerateMethodBody(MethodInfo method, IEnumerable<Dependency> dependencies)
{
    var sb = new StringBuilder();
    
    // Generate dependency resolution statements
    foreach (var dep in dependencies)
    {
        sb.AppendLine($"    var {dep.VariableName} = Get{dep.TypeName}();");
    }
    
    // Generate return statement
    sb.AppendLine($"    return {method.SpecificationClassName}.{method.MethodName}({string.Join(", ", dependencies.Select(d => d.VariableName))});");
    
    return sb.ToString();
}
```

## Testing Generated Code

### 1. Snapshot Tests

Verify generated code structure:

```csharp
[Test]
public void GenerateInjector_ProducesExpectedCode()
{
    // Arrange
    var spec = /* specification source code */;
    
    // Act
    var generated = GenerateCode(spec);
    
    // Assert
    Verify(generated) // Uses Verify.Tests library
        .IgnoreMembers(m => m.Name.Contains("LineNumber")) // Ignore volatile info
        .ScrubMember(m => m.Timestamp); // Remove timestamps
}
```

### 2. Execution Tests

Verify generated code actually works:

```csharp
[Test]
public void GeneratedInjector_ResolvesDependencies()
{
    // Compile generated code
    var assembly = Compile(generatorOutput);
    
    // Load and execute
    dynamic injector = assembly.CreateInstance("GeneratedInjector");
    var result = injector.GetMyType();
    
    // Verify
    Assert.That(result).IsNotNull;
    Assert.That(result).IsInstanceOf<MyType>();
}
```

### 3. Diagnostic Tests

Verify error reporting:

```csharp
[Test]
public void GenerateInjector_ReportsUnresolvableDependency()
{
    // Arrange
    var spec = """
        [Specification]
        public class BadSpec {
            [Factory]
            public MyType Create(UnregisteredDependency dep) => ...
        }
    """;
    
    // Act
    var diagnostics = Generate(spec).Diagnostics;
    
    // Assert
    Assert.That(diagnostics)
        .Contains(d => d.Descriptor == UnresolvableDependencyDescriptor);
}
```

## Validation Checklist

Before completing generator changes:

- [ ] Generated code is readable and formatted consistently
- [ ] All public generated types have `[GeneratedCode]` attribute
- [ ] Nullability is declared explicitly
- [ ] No runtime validation; all errors caught at generation time
- [ ] Performance: generator doesn't enumerate all symbols unnecessarily
- [ ] Incremental providers used for caching
- [ ] Snapshot tests verify generated code structure
- [ ] Execution tests verify generated code works
- [ ] Error diagnostics are clear and actionable
- [ ] `#nullable` directives used correctly
- [ ] File headers included (`<auto-generated />`, etc.)
- [ ] No comments stating the obvious
