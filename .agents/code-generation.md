# Code Generation Practices for PhxInject

Standards for writing source generators and for the code those generators produce. This applies to Phx.Inject.Generator.

## Source Generator Architecture

PhxInject uses incremental source generators for performance:

```csharp
[Generator]
public class PhxInjectSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1. Define input providers (what to analyze)
        // 2. Transform providers (analysis stages)
        // 3. Register output (generated code)
    }
}
```

### Incremental Generator Pattern

Structure generators following this pattern:

```csharp
[Generator]
public class MyAnalyzer : IIncrementalGenerator {
    public void Initialize(IncrementalGeneratorInitializationContext context) {
        // Define what to analyze using ForAttributeWithMetadataName
        var syntaxProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "Phx.Inject.SpecificationAttribute",
                predicate: (node, _) => true, // Filter: quick syntactic check
                transform: (ctx, _) => Transform(ctx)); // Transform to model
        
        // Transform: analysis stage
        var analyzed = syntaxProvider
            .Combine(context.CompilationProvider)
            .Select((pair, _) => Analyze(pair.Left, pair.Right));
        
        // Generate
        context.RegisterSourceOutput(analyzed, (ctx, item) => {
            ctx.AddSource($"{item.Name}.g.cs", item.GeneratedCode);
        });
    }
}
```

### Performance Considerations

**DO**:
- Use incremental providers for caching
- Return early from predicates to skip Roslyn parsing
- Cache expensive semantic analysis
- Use `HashCode` for determinate output

**DON'T**:
- Enumerate compilation symbols unnecessarily
- Re-analyze unchanged symbols
- Create many intermediate collections
- Call `FullyQualifiedName` repeatedly (cache results)

Example optimization:

```csharp
// Good: cache fully qualified names
private static string GetCachedName(INamedTypeSymbol symbol) {
    var key = SymbolEqualityComparer.Default.GetHashCode(symbol);
    if (_nameCache.TryGetValue(key, out var name)) {
        return name;
    }
    
    name = symbol.GetFullyQualifiedName();
    _nameCache[key] = name;
    return name;
}

// Avoid: repeated computation
var name1 = symbol.GetFullyQualifiedName();
var name2 = symbol.GetFullyQualifiedName(); // Recomputed
```

## Generated Code Standards

Code generated by the source generator must follow these standards:

### 1. Code Style

Generated code must be readable by human eyes:

```csharp
// Good: formatted and indented
public class GeneratedTestInjector : ITestInjector
{
    public int GetInt()
    {
        return TestSpecification.GetIntValue();
    }
    
    public MyClass GetMyClass()
    {
        var intValue = TestSpecification.GetIntValue();
        return TestSpecification.GetMyClass(intValue);
    }
}

// Avoid: compressed/unreadable
public class GeneratedTestInjector:ITestInjector{public int GetInt(){return TestSpecification.GetIntValue();}}
```

### 2. Source Information

Always include source information for debugging:

```csharp
[System.CodeDom.Compiler.GeneratedCode("Phx.Inject.Generator", "1.0")]
[System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
public class GeneratedTestInjector : ITestInjector
{
    // Generated implementation
}
```

Also include file comment:

```csharp
// <auto-generated />
// This file is generated by Phx.Inject.Generator.
// Do not modify directly - changes will be overwritten.
#pragma warning disable CS1591 // Missing XML documentation

namespace My.Project.Generated
{
    // ...
}
```

### 3. Nullability

Generated code must declare nullability explicitly:

```csharp
#nullable enable

public class GeneratedInjector : IMyInjector
{
    // Declare that methods never return null
    public string GetName() => GetNameFromSpec();
    
    // Or may be null
    public string? GetOptionalName() => _spec.GetOptionalName();
}

#nullable restore
```

### 4. Method Generation

**Simple Factories**

```csharp
// For static factory with no parameters
public MyType GetMyType() => MySpec.CreateMyType();

// For factory with dependencies
public MyType GetMyType()
{
    var dependency = GetDependency();
    return MySpec.CreateMyType(dependency);
}
```

**Builders**

```csharp
public void Build(MyType target)
{
    var dependency = GetDependency();
    MySpec.BuildMyType(target, dependency);
}
```

**Chaining Dependencies**

```csharp
// If A depends on B depends on C:
public A GetA()
{
    var c = GetC();  // Leaf dependency
    var b = GetB(c); // Intermediate
    return GetA(b);  // Root
}
```

### 5. Error Prevention

Generated code must validate at generation time, not runtime:

**Good**: Validation errors as diagnostics
```csharp
// In generator, not in generated code:
if (!CanResolveDependency(method)) {
    context.ReportDiagnostic(Diagnostic.Create(
        UnresolvableDependencyDescriptor,
        method.Locations[0],
        method.Name));
    return; // Don't generate broken code
}
```

**Avoid**: Runtime validation in generated code
```csharp
// Don't generate this:
public MyType GetMyType()
{
    if (depedency == null) {
        throw new InvalidOperationException("Dependency not configured");
    }
    return dependency.Create();
}
```

### 6. Comments in Generated Code

Only include comments when behavior is non-obvious:

```csharp
// Good: explains why this chain is necessary
public MyType GetMyType()
{
    // Dependency A requires B, which requires C; resolve in order
    var c = GetC();
    var b = GetB(c);
    return GetA(b);
}

// Avoid: obvious comments
public MyType GetMyType()
{
    // Get C
    var c = GetC();
    // Get B passing C
    var b = GetB(c);
    // Return A passing B
    return GetA(b);
}
```

## Template Generation

For generating method bodies, use StringBuilder with proper indentation:

```csharp
private static string GenerateMethodBody(
    MethodInfo method, 
    IEnumerable<Dependency> dependencies)
{
    var sb = new StringBuilder();
    
    // Generate dependency resolution statements
    foreach (var dep in dependencies)
    {
        sb.AppendLine($"    var {dep.VariableName} = Get{dep.TypeName}();");
    }
    
    // Generate return statement
    var args = string.Join(", ", dependencies.Select(d => d.VariableName));
    sb.AppendLine($"    return {method.SpecificationClassName}.{method.MethodName}({args});");
    
    return sb.ToString();
}
```

## Testing Generated Code

Testing strategy is not yet defined. See [Testing Standards](../testing.md) for current status.

## Validation Checklist

Before completing generator changes:

- [ ] Generated code is readable and formatted consistently
- [ ] All public generated types have `[GeneratedCode]` attribute
- [ ] Nullability is declared explicitly
- [ ] No runtime validation; all errors caught at generation time
- [ ] Performance: generator doesn't enumerate all symbols unnecessarily
- [ ] Incremental providers used for caching
- [ ] Error diagnostics are clear and actionable
- [ ] `#nullable` directives used correctly
- [ ] File headers included (`<auto-generated />`, etc.)
- [ ] No comments stating the obvious
